# Архитектурный обзор движка

> Всё описание на русском, но мы используем англоязычные идентификаторы и комментарии в коде.

## Философия

- **Три слоя**: PixiJS (view) ↔ Nanostores + GameObject-Component (logic/state) ↔ Capacitor (platform). Коммуникация внутри слоя плотная, между слоями — через чётко описанные адаптеры.
- **Компонентная архитектура прежде всего**: `GameObject` собираются из независимых компонентов, которые содержат данные и логику. Системы используются для глобальных процессов, затрагивающих множество объектов.
- **Stores — единственный мост** между игровым миром и UI. Никаких прямых вызовов Pixi ↔ Svelte, только события/действия, которые обновляют Nanostores.
- **Конфигурируемость**: все игровые балансы, таблицы ресурсов и пр. лежат в `src/stores/game/Config.ts` и автогенерируемых базах данных (`src/generated`). Любые новые значения — только через конфиги.
- **Малые модули**: делим всё на короткие файлы и чистые функции. Любая новая функциональность — отдельный компонент/система/стор.
- **Два режима**: игра (`game`) и редактор сцен (`scene-editor`) с переключением через `appMode` стор.

## Слои и запуск

1. **Platform Layer** (`capacitor.config.ts`, плагины). Отвечает за окружение, нативные возможности и сборку на устройстве.
2. **State & Logic Layer**:
   - **Игровое ядро** (`src/engine`) — менеджеры, сцены, эффекты, input, системы.
   - **Game data** (`src/game`) — конкретные компоненты, системы, сцены, графика.
   - **Nanostores** (`src/stores`) — глобальное состояние, синхронизация игры и UI, персист.
   - **Scene Editor** (`src/scene-editor`) — редактор сцен с инспектором и viewport.
3. **View Layer**:
   - **Pixi** (`src/engine/render`, `src/game/scenes`) — канвас, слои, эффекты.
   - **Svelte 5** (`src/App.svelte`, `src/ui`) — интерфейс и панели, Tailwind 4.

`src/main.ts` — точка входа. Последовательность:

1. Инициализация логгера и error overlay.
2. `mount(App)` — запускаем Svelte UI.
3. `PreGameLoader.load()` — загружаем шрифты и базовые сервисы.
4. `initGame()` — создаём `Game`, инициализируем менеджеры (asset, renderer, input, audio, effects, ticker).
5. Выбираем сцену по `appMode`: `GameScene` или `SceneEditorScene`.
6. Запускаем игру → `Game.startGame()` → `Ticker.start()` → `Game.update(dt)` → `SceneManager().update(dt)`.
7. HMR поддержка для горячей замены сцен и шейдеров.

## Игровое ядро (`src/engine`)

### Менеджеры

- `AssetManager` — async загрузка текстур, шрифтов, аудио через PIXI Loader.
- `PixiRenderer` — управляет WebGL/WebGPU рендером, сценой, лимитом FPS.
- `InputManager` — нормализованный инпут (клавиатура/тач/мышь), обновляется каждый кадр.
- `EffectSystem` — визуальные эффекты, частицы, шейдеры; сцена задаёт контейнер и слои.
- `AudioManager` — музыка/звук, завязан на конфиг, использует Howler.js.
- `ServiceRegistry` — DI-хранилище для вспомогательных сервисов.
- `PreGameLoader` — предзагрузка шрифтов и базовых сервисов.

Менеджеры отдаются сценам через `Game.getManagers()`, чтобы сцены не зависели от глобалей.

### Сцены и геймлуп

- `Scene` — базовый класс. Содержит `gameObjects`, `pre/postUpdate` шаги, хук `onEnter/onExit`.
- `SceneManager` — одиночка, переключает сцены, поддерживает горячую замену для HMR.
- `GameObject` — контейнер компонентов. Всё поведение — в компонентах.
- `Game` — главный класс, управляет жизненным циклом игры и менеджерами.
- `Ticker` — управление игровым циклом на основе `requestAnimationFrame` с delta time.

### Компоненты и системы

- Компоненты (`src/engine/components`, `src/game/components`) — содержат данные и логику, наследуются от `Component`. Имеют lifecycle hooks: `onAdded`, `onRemoved`, `onUpdate`.
- Системы (`src/engine/systems`, `src/game/systems`) — наследуются от `System`. Используются для глобальных процессов, затрагивающих множество объектов. Имеют `start/stop/update`.
- `TweenComponent` — анимации через GSAP, интегрирован с компонентной архитектурой.
- `PixiSpriteRenderer`, `PixiTextRenderer` — рендеринг через PIXI.
- `VelocityComponent` — движение объектов.

### События

- `eventBus` (`src/engine/events/EventBus.ts`) — глобальная шина событий.
- `DOMEventBridge` — мост между DOM событиями и игровыми событиями.
- Компоненты и системы подписываются через `eventBus.on` / `eventBus.emit`.
- Доменные события (например, `object-destroyed`) публикуются в game layer.

### Рендер и координаты

- `LayoutEngine` — вычисляет безопасную область, масштаб, позиции слоёв.
- `LayerManager` — управляет слоями рендеринга с заданными глубинами.
- `CoordinateService` — синхронизирует мировые координаты и UI.
- `panelPositioningService` — управляет позиционированием UI панелей.

## Game layer (`src/game`)

- `components` — игровые компоненты с данными и логикой (астероиды, фон, майнинг зона, клики).
- `systems` — глобальные системы (спаун астероидов, поля шумов, майнинг и т.п.).
- `prefabs` — фабрики для `GameObject` из компонентов.
- `graphics` — текстуры, фильтры, шейдеры для игровых объектов.
- `scenes` — композиция объектов и систем. `GameScene` подключает фон, астероиды, физику, layout.
- `events` — игровые события и их обработчики.
- `assets` — сервис загрузки игровых ассетов.

## Состояние и Nanostores (`src/stores`)

### Game stores (`src/stores/game`)

- `profileStore` (`map<PlayerProfile>`) — главный стор профиля и прогресса.
- `persistence.ts` — автосохранение в storage, debounce 1 секунда.
- `initialization.ts` — загрузка профиля на старте.
- `Config.ts` — централизованные игровые балансы и конфигурация.
- Любые новые данные игры → расширяем профиль, не создаём отдельные глобальные singletons.

### UI stores (`src/stores/ui`)

- `appState.ts` — режим приложения (`game` | `scene-editor`).
- `layout.ts` — состояние лейаута и позиционирования панелей.

### Правила интеграции UI ↔ GameObject-Component

- Компонент в Pixi изменяет игру → обновляет Nanostore (например, addResource).
- UI реагирует на Nanostore через `$store` или selectors → обновляет представление.
- UI инициирует действие (покупка апгрейда) → вызывает action в Nanostore → Nanostore генерирует события → компоненты реагируют (через eventBus или polling).
- Напрямую тащить Pixi объекты в Svelte нельзя.

## UI слой (`src/ui`)

### Svelte 5 и стилизация

- **Svelte 5 runes**: используем `$props`, `$derived`, `$inspect`. Не применяем `createEventDispatcher`, вместо этого — коллбеки из пропсов.
- **Tailwind 4**: кастомные утилити-классы из `src/styles/theme.css`, не хардкодим цвета.
- **Motion One** (`motion`) — для анимаций, включаем `hardwareAccelerated: true`.

### Компоненты

- **Базовые компоненты** (`src/ui/base`) — кнопки, панели, иконки, карточки. Используем их вместо `div`, где возможно.
- **Иконки** (`Icon.svelte`) — централизованная система иконок через Lucide Svelte.
- **Панели** (`src/ui/panels`) — регистрируются в `panelPositioningService`, используют `animations.panelSlideIn`.
- **Модальные окна** (`src/ui/modals`) — для диалогов и всплывающих окон.

### Структура UI

- `App.svelte` — главный компонент, переключает между игрой и редактором сцен.
- `GameHUD.svelte` — игровой интерфейс с панелями ресурсов.
- `ResourcePanel.svelte` — панель отображения ресурсов игрока.

## Scene Editor (`src/scene-editor`)

### Архитектура редактора

- **Data-Driven подход**: инспектор строится автоматически на основе данных компонентов.
- **Reflection-based**: использование метаданных TypeScript для генерации UI.
- **Flexbox layout**: редактор использует flexbox, не нужна система позиционирования панелей.

### Компоненты редактора

- `SceneEditor.svelte` — главный компонент с тремя панелями.
- `SceneGraph.svelte` — иерархия объектов сцены.
- `SceneViewport.svelte` — viewport для редактирования сцены.
- `Inspector.svelte` — инспектор свойств выбранного объекта.
- `Toolbar.svelte` — панель инструментов.

### Система выбора и инспектора

- `selection.ts` — стор для выбранной сущности (`$selectedEntityId`).
- Динамический инспектор на основе метаданных компонентов.
- Планируется поддержка декораторов `@editable` для автоматической генерации полей.

### Интеграция с GameObject-Component

- Редактор работает с теми же `GameObject` и компонентами, что и игра.
- `SceneEditorScene` — специальная сцена для редактора.
- Переключение между режимами через `appMode` стор.

## Рендер и лейаут

- `LayoutEngine` (`src/engine/render/LayoutEngine.ts`) вычисляет безопасную область, масштаб, позиции слоёв.
- `REF` — базовое разрешение (ширина/высота), используется для расчёта координат.
- `CoordinateService` синхронизирует мировые координаты и UI.
- `panelPositioningService` — управляет позиционированием UI панелей относительно layout.

## Загрузка и ассеты

- `PreGameLoader` — предварительно загружает текстуры, шрифты, данные.
- Assets лежат в `public/` и `src/assets/`. Используем менеджер, прямые `new PIXI.Texture` запрещены.
- Шрифты и иконки регистрируются в Tailwind тема.

## Настройки и конфиги

- `src/stores/game/Config.ts` — источник балансов. Системы читают значения оттуда, не используют литералы.
- Справочники ресурсов/апгрейдов генерятся скриптами и лежат в `src/generated`.
- Для новых сущностей: сначала обновить конфиг/генератор → потом использовать в коде.

## Расширение движка

> Базовый сценарий добавления новой механики:

1. Обновляем конфиги в `src/stores/game/Config.ts` (ресурсы, апгрейды).
2. Создаём компоненты с данными и логикой в `src/game/components`.
3. При необходимости пишем систему (`System` наследник) в `src/game/systems` для глобальных процессов.
4. Подключаем компоненты/системы в нужной сцене (`onEnter`), добавляем в `update`/`postUpdate`.
5. Если механика влияет на UI — добавляем действия/селекторы в Nanostores.
6. UI компоненты подписываются на стор, отображают данные.
7. Для визуальных эффектов используем `EffectSystem` и `TweenComponent`.

### Добавление новых компонентов

- Компоненты содержат данные и логику, наследуются от `Component`.
- Используем lifecycle hooks: `onAdded`, `onRemoved`, `onUpdate`.
- Для рендеринга создаём соответствующие компоненты в `src/game/components`.

### Добавление новых UI компонентов

- Базовые компоненты в `src/ui/base/`.
- Используем Tailwind классы из `src/styles/theme.css`.
- Для анимаций — Motion One с `hardwareAccelerated: true`.
- Панели регистрируются в `panelPositioningService`.

## Диагностика и отладка

### Логирование
- Логгер (`src/engine/logging`) доступен во всех слоях. Используем `logger.info/debug/warn/error`.
- Debug overlay и Spector.js подтягиваются в dev-режиме (`spectorDebugger`).

### Debug Console
- `DebugConsoleService` — консольные команды для инспекции ECS и PixiJS в dev-режиме.
- Доступен через `window.debug` в консоли браузера.
- Команды: `debug.help()`, `debug.entities()`, `debug.pixi()`, `debug.fps()` и др.

### HMR и разработка
- HMR поток: `main.ts` слушает `import.meta.hot`, аккуратно делает teardown.
- Scene editor (`src/scene-editor`) — отдельный режим приложения, переключается сторами `appMode`.
- `bun run build` — проверка TypeScript ошибок.
- `bun run tsc --noEmit path/to/file.ts` — проверка конкретного файла.

## Мобильные особенности

- Safe area (`src/utils/safeZoneTest.ts`) и `readSafeInsets()` — must-have для адаптивной верстки.
- `panelPositioningService` учитывает оффсеты (пример — resource panel в правилах).
- Аудио и эффекты можно отключить через конфиг для low-end устройств.
- Capacitor для нативных возможностей (haptics, preferences).

## Команды разработки

```bash
# Разработка
bun run dev

# Сборка
bun run build

# Мобильная разработка
bun run cap:sync
bun run cap:run

# Проверки
bun run check
bun run tsc --noEmit path/to/file.ts
```

## Что важно помнить

- Любой новый модуль обязан проверять совместимость с компонентной архитектурой и Nanostores.
- Не вставляем бизнес-логику в компоненты UI — только подписка/отображение.
- Для тяжелых операций смотрим в `SharedSystems-*` (bundle splitting).
- Поддерживаем FPS и минимизируем аллокации (пулы объектов, повторное использование контейнеров).
- Используем `@` алиасы вместо `..` для импортов.
- Логируем через `logger` вместо `console.log`.

Если нужно расширить архитектуру — сначала обновляем `docs/architecture.md`, описываем изменения, затем приступаем к реализации.